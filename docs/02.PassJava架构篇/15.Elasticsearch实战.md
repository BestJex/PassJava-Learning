

上篇我们讲到了 Elasticsearch 全文检索的原理，通过在本地搭建一套 ES 服务，以多个案例来分析了 ES 的原理以及基础使用。这次我们来讲下 SpringBoot 中如何整合 ES，以及如何在项目中使用 ES 来实现全文检索。

另外我在这里再次提下全文检索是什么：

**全文检索：** 指以全部文本信息作为检索对象的一种信息检索技术。而我们使用的数据库，如 Mysql，MongoDB 对文本信息检索能力特别是中文检索并没有 ES 强大。所以我们来看下 ES 在项目中是如何来代替 SQL 来工作的。

通过本实战您可以学到如下知识点：

- Spring Boot 如何整合 ES
- ES 的 API 使用
- 项目中如何使用 ES 来达到全文检索目的

本篇主要内容如下：

---

<思维导图>



本文案例都是基于 PassJava 实战项目来演示的。

Github 地址：https://github.com/Jackson0714/PassJava-Platform

## 一、Elasticsearch 组件库介绍

我使用的 Elasticsearch 服务是 7.4.2 的版本，然后采用官方提供的 Elastiscsearch-Rest-Client 库来操作 ES，而且官方库的 API 上手简单。

该组件库的官方文档地址：

```
https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/java-rest-high.html
```

另外这个组件库是支持多种语言的：

![支持多语言](http://cdn.jayh.club/blog/20210324/fg7pE47tRdC6.png?imageslim)

注意：`Elasticsearch Clients` 就是指如何用 API 操作 ES 服务的组件库。

可能有同学会提问，Elasticsearch 的组件库中写着 JavaScript API，是不是可以直接在前端访问 ES 服务？可以是可以，但是会暴露 ES 服务的端口和 IP 地址，会非常不安全。所以我们还是用后端服务来访问 ES 服务。

我们这个项目是 Java 项目，自然就是用上面的两种：`Java Rest Client` 或者 `Java API`。我们先看下 Java API，但是会发现已经废弃了。如下图所示：

![Java API 已经废弃了](http://cdn.jayh.club/blog/20210324/qPTAYbNhHzwA.png?imageslim)

所以我们只能用 Java REST Client 了。而它又分成两种：高级和低级的。高级包含更多的功能，如果把高级比作MyBatis的话，那么低级就相当于JDBC。所以我们用高级的 Client。

![高级和低级 Client](http://cdn.jayh.club/blog/20210330/Se52lN1s5wME.png?imageslim)

## 二、Spring Boot 整合 Elasticsearch

我们把检索服务单独作为一个服务。就称作 passjava-search 模块吧。

### 1.1 添加搜索服务模块

- 创建 passjava-search 模块。

首先我们在 PassJava-Platform 模块创建一个 搜索服务模块 passjava-search。然后勾选 spring web 服务。如下图所示。

第一步：选择 Spring Initializr，然后点击 Next。

![选择 Spring Initializr](http://cdn.jayh.club/blog/20201008/XKlqVxQ83s8v.png?imageslim)

第二步：填写模块信息，然后点击 Next。

![passjava-search 服务模块](http://cdn.jayh.club/blog/20201008/OLby7KmG76Uh.png?imageslim)

第三步：选择 Web->Spring Web 依赖，然后点击 Next。

![mark](http://cdn.jayh.club/blog/20210330/4zSqqaqvEdHw.png?imageslim)

### 1.2 配置 Maven 依赖

- 参照 ES 官网配置。

进入到 ES 官方网站，可以看到有低级和高级的 Rest Client，我们选择高阶的（High Level Rest Client）。然后进入到高阶 Rest Client 的 Maven 仓库。官网地址如下所示：

``` sh
https://www.elastic.co/guide/en/elasticsearch/client/java-rest/7.9/index.html
```

![Rest Client 官方文档](http://cdn.jayh.club/blog/20201008/IIcFSMBBHgkc.png?imageslim)

- 加上 Maven 依赖。

  对应文件路径：\passjava-search\pom.xml

``` xml
<dependency>
    <groupId>org.elasticsearch.client</groupId>
    <artifactId>elasticsearch-rest-high-level-client</artifactId>
    <version>7.4.2</version>
</dependency>
```

- 配置 elasticsearch 的版本为7.4.2

  因加上 Maven 依赖后，elasticsearch 版本为 7.6.2，所以遇到这种版本不一致的情况时，需要手动改掉。
  
  对应文件路径：\passjava-search\pom.xml

``` XNK
<properties>
	<elasticsearch.version>7.4.2</elasticsearch.version>
</properties>
```

刷新 Maven Project 后，可以看到引入的 elasticsearch 都是 7.4.2 版本了，如下图所示：

![设置版本为 7.4.2](http://cdn.jayh.club/blog/20201008/bboz9aCt91NE.png?imageslim)

- 引入 PassJava 的 Common 模块依赖。

  Common 模块是 PassJava 项目独立的出来的公共模块，引入了很多公共组件依赖，其他模块引入 Common 模块依赖后，就不需要单独引入这些公共组件了，非常方便。
  
  对应文件路径：\passjava-search\pom.xml

``` xml
 <dependency>
     <groupId>com.jackson0714.passjava</groupId>
     <artifactId>passjava-common</artifactId>
     <version>0.0.1-SNAPSHOT</version>
</dependency>
```

添加完依赖后，我们就可以将搜索服务注册到 `Nacos` 注册中心了。 Nacos 注册中心的用法在前面几篇文章中也详细讲解过，这里需要注意的是要先启动 Nacos 注册中心，才能正常注册 passjava-search 服务。

### 1.3 注册服务到注册中心

修改配置文件：src/main/resources/application.properties。配置应用程序名、注册中心地址、注册中心的命名中间。

``` properties
spring.application.name=passjava-search
spring.cloud.nacos.config.server-addr=127.0.0.1:8848
spring.cloud.nacos.config.namespace=passjava-search
```

给`启动类`添加服务发现注解：`@EnableDiscoveryClient`。这样 passjava-search 服务就可以被注册中心发现了。

因 Common 模块依赖数据源，但 search 模块不依赖数据源，所以 search 模块需要移除数据源依赖：

```java
exclude = DataSourceAutoConfiguration.class
```

以上的两个注解如下所示：

```java
@EnableDiscoveryClient
@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)
public class PassjavaSearchApplication {
    public static void main(String[] args) {
        SpringApplication.run(PassjavaSearchApplication.class, args);
    }
}
```

接下来我们添加一个 ES 服务的专属配置类，主要目的是自动加载一个 ES Client 来供后续 ES API 使用，不用每次都 new 一个 ES Client。

### 1.4 添加 ES 配置类

配置类：PassJavaElasticsearchConfig.java

核心方法就是 RestClient.builder 方法，设置好 ES 服务的 IP 地址、端口号、传输协议就可以了。最后自动加载了 RestHighLevelClient。

```java
package com.jackson0714.passjava.search.config;

import org.apache.http.HttpHost;
import org.elasticsearch.client.RestClient;
import org.elasticsearch.client.RestHighLevelClient;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * @Author: 公众号 | 悟空聊架构
 * @Date: 2020/10/8 17:02
 * @Site: www.passjava.cn
 * @Github: https://github.com/Jackson0714/PassJava-Platform
 */
@Configuration
public class PassJavaElasticsearchConfig {

    @Bean
    // 给容器注册一个 RestHighLevelClient，用来操作 ES
    // 参考官方文档：https://www.elastic.co/guide/en/elasticsearch/client/java-rest/7.9/java-rest-high-getting-started-initialization.html
    public RestHighLevelClient restHighLevelClient() {
        return new RestHighLevelClient(
                RestClient.builder(
                        new HttpHost("192.168.56.10", 9200, "http")));
    }
}

```

接下来我们测试下 ES Client 是否自动加载成功。

### 1.5 测试 ES Client 自动加载

在测试类 PassjavaSearchApplicationTests 中编写测试方法，打印出自动加载的 ES Client。期望结果是一个 RestHighLevelClient 对象。

```java
package com.jackson0714.passjava.search;

import org.elasticsearch.client.RestHighLevelClient;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class PassjavaSearchApplicationTests {

    @Qualifier("restHighLevelClient")
    @Autowired
    private RestHighLevelClient client;

    @Test
    public void contextLoads() {
        System.out.println(client);
    }
}
```

运行结果如下所示，打印出了 RestHighLevelClient。说明自定义的 ES Client 自动装载成功。

![ES 测试结果](http://cdn.jayh.club/blog/20201008/4gpzgYrKQ5vL.png?imageslim)

### 1.6 测试 ES 简单插入数据

测试方法 testIndexData，省略 User 类。users 索引在我的 ES 中是没有记录的，所以期望结果是 ES 中新增了一条 users 数据。

```java
/**
 * 测试存储数据到 ES。
 * */
@Test
public void testIndexData() throws IOException {
    IndexRequest request = new IndexRequest("users");
    request.id("1"); // 文档的 id
    
    //构造 User 对象
    User user = new User();
    user.setUserName("PassJava");
    user.setAge("18");
    user.setGender("Man");
    
    //User 对象转为 JSON 数据
    String jsonString = JSON.toJSONString(user);
    
    // JSON 数据放入 request 中
    request.source(jsonString, XContentType.JSON);

    // 执行插入操作
    IndexResponse response = client.index(request, RequestOptions.DEFAULT);

    System.out.println(response);
}
```

执行 test 方法，我们可以看到控制台输出以下结果，说明数据插入到 ES 成功。另外需要注意的是结果中的 result 字段为 updated，是因为我本地为了截图，多执行了几次插入操作，但因为 id = 1，所以做的都是 updated 操作，而不是 created 操作。

![控制台输出结果](http://cdn.jayh.club/blog/20201014/7FpsoV1fzT2w.png?imageslim)

我们再来到 ES 中看下 users 索引中数据。查询 users 索引：

``` sh
GET users/_search
```

结果如下所示：

![查询 users 索引结果](http://cdn.jayh.club/blog/20201014/PENUrSXiHBlR.png?imageslim)

可以从图中看到有一条记录被查询出来，查询出来的数据的 _id = 1，和插入的文档 id 一致。另外几个字段的值也是一致的。说明插入的数据没有问题。

``` json
"age" : "18",
"gender" : "Man",
"userName" : "PassJava"
```

### 1.7 测试 ES 查询复杂语句

> 示例：搜索 bank 索引，address 字段中包含 big 的所有人的年龄分布 ( 前 10 条 ) 以及平均年龄，以及平均薪资。

我们可以参照官方文档给出的示例来创建一个 SearchRequest 对象，指定要查询的索引为 bank，然后创建一个 SearchSourceBuilder 来组装查询条件。总共有三种条件需要组装：

- address 中包含 big 的所有人。
- 按照年龄分布进行聚合。
- 计算平均薪资。

代码如下所示，需要源码请到我的 Github/PassJava 上下载。

![查询复杂语句示例](http://cdn.jayh.club/blog/20201015/RJtuH9CpUa9H.png?imageslim)

将打印出来的检索参数复制出来，然后放到 JSON 格式化工具中格式化一下，再粘贴到 ES 控制台执行，发现执行结果是正确的。

![打印出检索参数](http://cdn.jayh.club/blog/20201015/IRiUeDIFjRAL.png?imageslim)

用在线工具格式化 JSON 字符串，结果如下所示：

<img src="http://cdn.jayh.club/blog/20201015/Q6OCLg0bwTMo.png?imageslim" alt="格式化 JSON 字符串" style="zoom:50%;" />

然后我们去掉其中的一些默认参数，最后简化后的检索参数放到 Kibana 中执行。

Kibana Dev Tools 控制台中执行检索语句如下图所示，检索结果如下图所示：

![控制台中执行检索语句](http://cdn.jayh.club/blog/20201015/2lMEF72wOc3b.png?imageslim)

找到总记录数：29 条。

第一条命中记录的详情如下：

平均 balance：13136。

平均年龄：26。

地址中包含 Road 的：263 Aviation Road。

和 IDEA 中执行的测试结果一致，说明复杂检索的功能已经成功实现。

而获取命中记录的详情数据，则需要通过两次 getHists() 方法拿到，如下所示：



```
// 3.1）获取查到的数据。
SearchHits hits = response.getHits();
// 3.2）获取真正命中的结果
SearchHit[] searchHits = hits.getHits();
```

我们可以通过遍历 searchHits 的方式打印出所有命中结果的详情。









# 附录一、FAQ

访问不了 Kibana http://192.168.56.10:5601/

浏览器页面报错

Cannot connect to the Elasticsearch cluster

![mark](http://cdn.jayh.club/blog/20201007/Wvp4ewOkMXBp.png?imageslim)

查看 Elasticsearch 日志

``` sh
docker logs <容器 id>
```

报错信息如下：

org.elasticsearch.action.NoSharedAvailableActionException

![mark](http://cdn.jayh.club/blog/20201007/zbx3pW9xwPSw.png?imageslim)

解决方案：

浏览器用隐私模式打开 ctrl + shift + N